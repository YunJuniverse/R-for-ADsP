rm(list=ls()) # 변수 목록 삭제
iv <- c(1,2,3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE, TRUE)
fv <- c(3.4, 2.5, 8)
t <- c(1, 2, 3, 4)
icv <- c(iv, cv, bv)

rm(list=ls()) # 변수 목록 삭제
v1 = seq(1, 5)
v11 = 1:5
v2 = seq(1, 10, 2)
v3 = seq(1, 10, length=4) # 수열 균등 분배
v4 = seq(1, 3, length=5)

rm(list=ls()) # 변수 목록 삭제
v1 = rep(1, 5)
v2 = rep(1, time=5)
v3 = rep(3:5, 3) # 3에서 5까지 3번 반복
v4 = rep(1:3, each=2) # 1에서 3까지 각각 반복
v5 = rep(seq(1,5,2),2) # 1부터 5까지 2개씩(by) 2번 반복
v5 = rep(seq(1,5,2),each=2) # 1부터 5까지 2개씩(by) 각각 2번 반복

# 벡터의 연산
rm(list=ls()) # 변수 목록 삭제
v1 <- seq(2,10,2) #2부터 10까지 2개씩
v2 <- rep(2,5)
v3 <- v1 + v2
v4 <- v1 %/% v2 # 몫
v5 <- v1^v2 # 거듭제곱
x <- c(1, 4)
y <- c(2, 3)
z <- t(y) # 전치행렬(transposed) 행과 열을 바꾸는 것
m <- x %*% z # 행렬곱
cat(m)


rm(list=ls()) # 변수 목록 삭제
v1 = rep(3, 6)
v2 <- c(1, 2, 3)
v3 <- v1+v2 # 더 큰 벡터의 수만큼 반복해서 연산한다. 
# 만약 길이가 맞지 않으면 연산 오류가 난다! v1이 7개면 오류
v4 <- v2 + 3

# 벡터의 인덱싱
rm(list=ls()) # 변수 목록 삭제
v1 <- 1:5 # c(1,5)
r1 <- v1[3] # 3번에 있는걸 가져온다
r2 <- v1[-3] # 3번에 있는걸 빼고 가져온다.
r3 <- v1[2:4] # 2에서 4에 해당하는 인덱스 값을 가져온다
r4 <- v1[2:2] # 스칼라 값(길이가 1인 벡터)만 가져옴
v1%%2==0 # 나머지, True, false로 결과 출력
r5 <- v1[v1%%2==0] # 짝수만 출력
names(v1) = c('A', 'B', 'C', 'D', 'E')
r6 = v1['B']
r7 = v1[2]